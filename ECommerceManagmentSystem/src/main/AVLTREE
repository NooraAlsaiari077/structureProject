package main;
import java.util.ArrayList;

public class AVL <T> {
	
	AVLNode<T> root, current;

    public AVL() {
        root = current = null;
    }

    public boolean empty() {
        return root == null;
    }

    public T retrieve() {
        return current != null ? current.data : null;
    }

    // -------- HEIGHT / BALANCE --------

    private int getHeight(AVLNode<T> n) {
        return (n == null) ? 0 : n.height;
    }

    private void updateHeight(AVLNode<T> n) {
        n.height = 1 + Math.max(getHeight(n.left), getHeight(n.right));
    }

    private int getBalance(AVLNode<T> n) {
        return (n == null) ? 0 : getHeight(n.left) - getHeight(n.right);
    }

    // -------- ROTATIONS --------

    private AVLNode<T> rightRotate(AVLNode<T> y) {
        AVLNode<T> x = y.left;
        AVLNode<T> T2 = x.right;

        x.right = y;
        y.left = T2;

        updateHeight(y);
        updateHeight(x);

        return x;
    }

    private AVLNode<T> leftRotate(AVLNode<T> x) {
        AVLNode<T> y = x.right;
        AVLNode<T> T2 = y.left;

        y.left = x;
        x.right = T2;

        updateHeight(x);
        updateHeight(y);

        return y;
    }

    // -------- FIND --------

    public boolean findkey(int tkey) {
        AVLNode<T> p = root, q = root;
        if (empty()) return false;

        while (p != null) {
            q = p;
            if (p.key == tkey) {
                current = p;
                return true;
            } else if (tkey < p.key)
                p = p.left;
            else
                p = p.right;
        }

        current = q;
        return false;
    }

    // -------- INSERT --------

    public boolean insert(int key, T val) {
        if (findkey(key)) return false;
        root = insertRec(root, key, val);
        findkey(key);
        return true;
    }

    private AVLNode<T> insertRec(AVLNode<T> node, int key, T value) {
        if (node == null) return new AVLNode<>(key, value);

        if (key < node.key)
            node.left = insertRec(node.left, key, value);
        else if (key > node.key)
            node.right = insertRec(node.right, key, value);
        else {
            node.data = value;
            return node;
        }

        updateHeight(node);
        int balance = getBalance(node);

        // LL
        if (balance > 1 && key < node.left.key)
            return rightRotate(node);

        // RR
        if (balance < -1 && key > node.right.key)
            return leftRotate(node);

        // LR
        if (balance > 1 && key > node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // RL
        if (balance < -1 && key < node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    // -------- DELETE --------

    public boolean remove_key(int key) {
        root = deleteRec(root, key);
        current = root;
        return true;
    }

    private AVLNode<T> deleteRec(AVLNode<T> node, int key) {
        if (node == null) return null;

        if (key < node.key)
            node.left = deleteRec(node.left, key);
        else if (key > node.key)
            node.right = deleteRec(node.right, key);
        else {
            // leaf or one child
            if (node.left == null || node.right == null) {
                AVLNode<T> temp = (node.left != null) ? node.left : node.right;
                if (temp == null)
                    return null;
                else
                    node = temp;
            } else {
                // two children: inorder successor
                AVLNode<T> temp = node.right;
                while (temp.left != null) temp = temp.left;

                node.key = temp.key;
                node.data = temp.data;

                node.right = deleteRec(node.right, temp.key);
            }
        }

        if (node == null) return null;

        updateHeight(node);
        int balance = getBalance(node);

        // LL
        if (balance > 1 && getBalance(node.left) >= 0)
            return rightRotate(node);

        // LR
        if (balance > 1 && getBalance(node.left) < 0) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // RR
        if (balance < -1 && getBalance(node.right) <= 0)
            return leftRotate(node);

        // RL
        if (balance < -1 && getBalance(node.right) > 0) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    // -------- INORDER TO ARRAYLIST --------

    public ArrayList<T> toArrayList() {
        ArrayList<T> list = new ArrayList<>();
        inorderFill(root, list);
        return list;
    }

    private void inorderFill(AVLNode<T> node, ArrayList<T> list) {
        if (node == null) return;
        inorderFill(node.left, list);
        list.add(node.data);
        inorderFill(node.right, list);
    }

    // -------- RANGE QUERY --------

    public ArrayList<T> rangeQuery(int min, int max) {
        ArrayList<T> result = new ArrayList<>();
        rangeRec(root, min, max, result);
        return result;
    }

    private void rangeRec(AVLNode<T> node, int min, int max, ArrayList<T> result) {
        if (node == null) return;
        if (node.key > min) rangeRec(node.left, min, max, result);
        if (node.key >= min && node.key <= max) result.add(node.data);
        if (node.key < max) rangeRec(node.right, min, max, result);
    }

}
